{
  "problem_id": "0141",
  "problem_title": "Linked List Cycle",
  "cards": [
    {
      "front": "[0141] Linked List Cycle - What is the main algorithmic pattern used to detect a cycle in a linked list with O(1) space?",
      "back": "The {{c1::fast and slow pointers}} technique (Floyd's Tortoise and Hare), where fast moves two steps and slow moves one step per iteration.",
      "tags": "linked-list fast-slow-pointers floyd algorithm NeetCode150",
      "card_type": "cloze"
    },
    {
      "front": "[0141] Linked List Cycle - Fill in the blank: If the fast and slow pointers ever __, a cycle exists.",
      "back": "meet",
      "tags": "fill-in-the-blank fast-slow-pointers cycle-detection linked-list NeetCode150",
      "card_type": "basic"
    },
    {
      "front": "[0141] Linked List Cycle - What is the time and space complexity of Floyd's Tortoise and Hare algorithm?",
      "back": "Time: {{c1::O(n)}} for a single traversal. Space: {{c2::O(1)}} since only pointers are used.",
      "tags": "complexity O(n) O(1) floyd fast-slow-pointers linked-list NeetCode150",
      "card_type": "cloze"
    },
    {
      "front": "[0141] Linked List Cycle - Step-by-step: How does the fast and slow pointer approach detect a cycle?",
      "back": "1. Initialize fast and slow pointers at head.\n2. Move fast by two steps and slow by one step each iteration.\n3. If fast and slow meet, a cycle exists.\n4. If fast reaches the end, no cycle exists.",
      "tags": "step-by-step fast-slow-pointers cycle-detection linked-list NeetCode150",
      "card_type": "basic"
    },
    {
      "front": "[0141] Linked List Cycle - True/False: Using a hash set to track visited nodes also detects cycles but uses O(n) space.",
      "back": "True; a hash set can detect cycles but is less space-efficient than the two-pointer method.",
      "tags": "hash-set alternative space-complexity cycle-detection linked-list NeetCode150",
      "card_type": "basic"
    },
    {
      "front": "[0141] Linked List Cycle - What is a common mistake when implementing the fast and slow pointer approach?",
      "back": "A common mistake is {{c1::not checking if fast and fast.next are valid}} before advancing, which can cause errors on short or empty lists.",
      "tags": "common-mistake fast-slow-pointers edge-case linked-list NeetCode150",
      "card_type": "cloze"
    },
    {
      "front": "[0141] Linked List Cycle - Analogy: How is the fast and slow pointer technique like two runners on a circular track?",
      "back": "If the faster runner (fast pointer) laps the slower runner (slow pointer), they will eventually meet if the track is circular (cycle exists).",
      "tags": "analogy fast-slow-pointers intuition linked-list NeetCode150",
      "card_type": "basic"
    },
    {
      "front": "[0141] Linked List Cycle - Interleaving: Which other problems use a similar fast and slow pointer technique?",
      "back": "Problems like 'Middle of the Linked List', 'Remove Nth Node From End Of List', and 'Palindrome Linked List' use similar fast and slow pointer strategies.",
      "tags": "interleaving fast-slow-pointers linked-list NeetCode150",
      "card_type": "basic"
    },
    {
      "front": "[0141] Linked List Cycle - Fill in the blank: Always check for __ or single-node lists before running the cycle detection algorithm.",
      "back": "empty",
      "tags": "edge-case empty-list fill-in-the-blank linked-list NeetCode150",
      "card_type": "basic"
    },
    {
      "front": "[0141] Linked List Cycle - True/False: Floyd's Tortoise and Hare algorithm is optimal for space complexity.",
      "back": "True; it uses only two pointers and no extra data structures.",
      "tags": "floyd optimal space-complexity fast-slow-pointers linked-list NeetCode150",
      "card_type": "basic"
    }
  ]
}
