{
  "problem_id": "0001",
  "problem_title": "Two Sum",
  "cards": [
    {
      "front": "[0001] Two Sum - What is the key data structure that enables an efficient solution to this problem?",
      "back": "A {{c1::hashmap (dictionary)}} is used to store previously seen numbers and their indices for constant-time lookups.",
      "tags": "array hashmap lookup NeetCode150",
      "card_type": "cloze"
    },
    {
      "front": "[0001] Two Sum - What is the main algorithmic pattern used in the optimal solution?",
      "back": "The {{c1::single-pass hashmap}} pattern, where you check for the complement as you iterate and store each number's index.",
      "tags": "array hashmap single-pass algorithm NeetCode150",
      "card_type": "cloze"
    },
    {
      "front": "[0001] Two Sum - Fill in the blank: For each number, check if {{c1::target - num}} exists in the hashmap before inserting the current number.",
      "back": "For each number, check if {{c1::target - num}} exists in the hashmap before inserting the current number.",
      "tags": "array hashmap complement fill-in-the-blank NeetCode150",
      "card_type": "cloze"
    },
    {
      "front": "[0001] Two Sum - True/False: The solution may return multiple pairs of indices for a single input.",
      "back": "False; the solution returns as soon as a valid pair is found, and only one valid answer exists per input.",
      "tags": "array hashmap unique-answer NeetCode150",
      "card_type": "basic"
    },
    {
      "front": "[0001] Two Sum - What is the time and space complexity of the optimal solution?",
      "back": "Time: {{c1::O(n)}}; Space: {{c2::O(n)}} due to the hashmap storing up to n elements.",
      "tags": "complexity hashmap array NeetCode150",
      "card_type": "cloze"
    },
    {
      "front": "[0001] Two Sum - Step-by-step: How does the algorithm find the two indices that sum to the target?",
      "back": "1. Iterate through the array. 2. For each number, compute its complement (target - num). 3. If the complement is in the hashmap, return its index and the current index. 4. Otherwise, store the current number and its index in the hashmap.",
      "tags": "step-by-step hashmap algorithm NeetCode150",
      "card_type": "basic"
    },
    {
      "front": "[0001] Two Sum - What edge cases should you consider when using this approach?",
      "back": "- Duplicates in the array (e.g., [3,3])\n- Negative numbers\n- The same element cannot be used twice (indices must be different)",
      "tags": "edge-case duplicates negative-numbers NeetCode150",
      "card_type": "basic"
    },
    {
      "front": "[0001] Two Sum - Common mistake: Why is it important to check for the complement before inserting the current number into the hashmap?",
      "back": "If you insert the current number first, you might pair an element with itself, violating the requirement to use two distinct indices.",
      "tags": "common-mistake hashmap order NeetCode150",
      "card_type": "basic"
    },
    {
      "front": "[0001] Two Sum - Analogy: How is the hashmap approach similar to looking up a phone number in a contact list?",
      "back": "Just as you quickly find a contact's number by name, the hashmap lets you instantly check if the needed complement has already been seen.",
      "tags": "analogy hashmap lookup NeetCode150",
      "card_type": "basic"
    }
  ]
}
